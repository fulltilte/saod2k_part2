Шведов Иван, 2013

1)	В C++ имеются локальные объекты, которые инициализируются внутри функций и их время жизни жёстко определено контекстом функции: как только функция закончит своё выполнение, то объект будет уничтожен. Динамические объекты, которые инициализируются с помощью оператора new и записываются в кучу (heap), уничтожаются с помощью оператора delete (delete[]), а время их жизни определяется программистом. 
При создании объекта-наследника происходит создание всех объектов родителей, а затем конструируется объект наследник. 
При создании объекта, имеющего поля, типизируемые определённым классом, сначала создаются объекты полей, а затем сам объект носитель.
В C# время жизни объектов зависит от сборщика мусора (не определено): если на объект больше нет ссылок, то уборщик мусора уничтожит объект во время следующей сборки.

2)	
a)  Неявное копирование происходит при передаче объекта, как параметр функции по значению и возвращении объекта функцией.
b)  Изначально создаются родительские объекты, объекты, которые присваиваются полям объекта-агрегата, а затем создаётся сам агрегат.
c)  Интерфейс IDisposable предназначен для реализации метода Dispose, который высвобождает занимаемые объектом управляемые и неуправляемые ресурсы.
d)  Dispose будет обязательно вызван для объекта, созданного в блоке using.
e)  Нужно явно вызвать конструктор родительского объекта в конструкторе дочернего (MyChildClass(int x, int y) : MyParentClass(x, y) { … }).
f)  В C# вызов конструктора предка происходит через команду base. (MyChildClass(int x, int y) : base(x, y) { … }).
g)  Нужно вызвать конструктор члена класса с параметрами в конструкторе класса-агрегата
h)  В C# ссылка это самостоятельная сущность, которая может либо ссылаться на объект или быть равной null, также ссылка может быть изменена самим сборщиком мусора во время уборки (избежание дефрагментации кучи). В C++ ссылка не может быть изменена после инициализации.
i)  template <class T> class MyNewTemplate: { … } — определение шаблона. MyTemplate<MyClass> template; — объявление переменной типа шаблона.
